<div class="row content" id="connect-four">
  <h1><a href="https://github.com/Thomascountz/odin_projects/tree/master/connectfour" target="none">Connect Four</a> <small>Ruby || RSpec || Algorithms || OOP</small></h1>
  <p>(opens in new tab)</p>
  
  <h2>What is this?</h2>
  
  <p>A link to a command-line Connect Four game I wrote while going through The Odin Project.</p>
  
  <h2>What does it do?</h2>
  
  <p><a href="https://en.wikipedia.org/wiki/Connect_Four" target="none">Connect Four</a>is a board game for two players. The board has a 6 x 7 where players take turns dropping their colored tokens into the bottom position of each of the seven columns. the first player to get four tokens in a row, either horizontally, vertically, or diagonally, wins! This command-line game is exactly that.</p>
  
  <h2>Abstraction. (...or whatever it's called.)</h2>
  
  <p>Firstly, writing this game really helped to understand OOP and TDD principles. My file tree looks like this:</p>
  
  <pre>
    .
    ├── connect_four.rb
    ├── lib
    │   ├── board.rb
    │   ├── game.rb
    │   └── player.rb
    ├── scrap.rb
    └── spec
        ├── board_spec.rb
        ├── game_spec.rb
        ├── player_spec.rb
        └── spec_helper.rb
  </pre>
  
  <p>As you can probably tell, my focus from early on was with the separation of concerns. Each class was contained with it's own file, and each class had it's own test.<br><br> speaking of tests, this project was my first experience using doubles like this <code>player1 = double('player')</code>. These, again helped me to keep my classes separated so that they can be tested independently.<br><br>The other very fun part of building this game was writing the <code>Board#win?</code>method. I approached this problem a few different way. The first thing to note is that I used a nested array to represent my board:
  
  <pre>
  [['.', '.', '.', '.', '.', '.', '.'],
   ['.', '.', '.', '.', '.', '.', '.'],
   ['.', '.', '.', '.', '.', '.', '.'],
   ['.', '.', '.', '.', '.', '.', '.'],
   ['.', '.', '.', '.', '.', '.', '.'],
   ['O', '.', '.', '.', '.', '.', '.']]
  </pre>
  
  <p>So therefore, the position where the "O" is located could be identified as <code>Board[5][0]</code> (The first element in the fifth array). When it came time to write a <code>Board#win</code> method, I first approched it recursively. I wanted the method to return true or false by following a "flood-fill" methodology. The idea was that when a token was played, those coodinates would be passed to <code>Board#win?</code>. The base cases are <code>if count == 4</code>, meaning that four tokens were found in sequence, or <code>if !row.between?(0, 5) && !column.between?(0, 6)</code>, meaning that the method was now out of the range of the board.<br><br>If the current position on the board was equal to the token, the method would check each position in each direction to see if there was a matching token, if so, it would move in that direction until either the <code>count == 4</code> or a matching token was not found.<br><br>In theory, this would work, and I'm still excited by the prospect of implementing this algorithm, as I think it is suitable, but instead, I settled on a non-recursive stradegy:</p>
  
  <pre>
  def horizontal_win?(args = {})
    token   = args.fetch(:token, nil)
    row     = args.fetch(:row, nil)
    column  = args.fetch(:column, nil)

    count = 0

    4.times do |i|
      count += 1 if column + i <= 6 && @play_area[row][column + i] == token
      count += 1 if column - i >= 0 && @play_area[row][column - i] == token
      return true if count == 5
    end

    false
  end
  </pre>
  
  <p>Where this was written to check horizontal wins, similar methods were written to check for diagonal and vertical wins. Firstly, this code accepts an <code>args</code> array to take the pressue of the method caller to keep track of so many representational numbers. Secondly, the code iterates four times and simply adds one to <count>count</count> if token in either direction matches the token that was just played.<br><br>I had some wierd edge case errors with the code initially, for example, when <code>column - i</code> would equal a negative number, the method was now testing the end of the array, and if their happened to be a matching token on the opposite side, a win would be returned. Luckily testing helped with this!</p>
  
  <pre>
    it 'returns false' do
      board.instance_variable_set(:@play_area,
                                  [['.', '.', '.', '.', '.', '.', '.'],
                                   ['.', '.', '.', '.', '.', '.', '.'],
                                   ['.', '.', '.', '.', '.', '.', '.'],
                                   ['.', '.', '.', '.', '.', '.', '.'],
                                   ['O', '.', '.', '.', '.', '.', '.'],
                                   ['O', '.', '.', '.', '.', '.', '.']])
      expect(board.win?(token: 'O', row: 4, column: 0)).to be false
    end
  </pre>
  
  <p>This test originally failed.<br><br> Overall, this was one of my favorite projects to work on. From end to end, I felt very confident, and now I'm excited to go back and refactor!</p>
  
  <h2>Where do we go from here?</h2>
  
  <p>Refactoring and playtime! With this code and tests in hand, I can now try to implement a recursive method to check for winning patterns, I can try to implement a <a href="https://chessprogramming.wikispaces.com/Bitboards">bitboard</a>, and I can deploy a frontend so that I can play online with friends!</p>
  
  <h2>What did I learn?</h2>
  
  <p>Well if I haven't gone through it all already, I've learned TDD with RSpec, OOP and separation of concerns, and to have fun trying new things.</p>    
</div>

